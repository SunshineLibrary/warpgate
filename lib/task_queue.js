// Generated by CoffeeScript 1.6.3
(function() {
  var Task, TaskQueue, amqp, bindExchange, clc, connect, declareExchange, declareQueue, events, subscribe, util;

  clc = require('cli-color');

  amqp = require('amqp');

  util = require('util');

  events = require('events');

  Task = require('./task').Task;

  exports.TaskQueue = TaskQueue = function(connectionParams, role, hostname) {
    if (!(role && hostname)) {
      return null;
    }
    this.connectionParams = connectionParams;
    this.queueName = 'warpgate.host.' + hostname;
    this.exchangeName = 'warpgate.role.' + role;
    return this;
  };

  util.inherits(TaskQueue, events.EventEmitter);

  TaskQueue.prototype.start = function(callback) {
    util.log('Connecting to RabbitMQ server...');
    return connect(this).on('connected', function(self) {
      util.log('Declaring listen queue: ' + self.queueName);
      return declareQueue(self, function() {
        return self.emit('queueOk', self);
      });
    }).on('queueOk', function(self) {
      util.log('Declaring exchange: ' + self.exchangeName);
      return declareExchange(self, function() {
        return self.emit('exchangeOk', self);
      });
    }).on('exchangeOk', function(self) {
      util.log('Binding ' + self.queueName + ' to ' + self.exchangeName);
      return bindExchange(self, function() {
        return self.emit('bindExchangeOk', self);
      });
    }).on('bindExchangeOk', function(self) {
      util.log(clc.green('Ready'));
      subscribe(self);
      if (callback) {
        return callback();
      }
    });
  };

  TaskQueue.prototype.end = function() {
    if (this.connection) {
      return this.connection.end();
    }
  };

  TaskQueue.prototype.handleMessage = function(message, header, delivderInfo, m) {
    var task;
    util.log('Received: ' + JSON.stringify(message));
    if (message.id && message.action) {
      task = new Task(message, function(isSuccess) {
        if (isSuccess == null) {
          isSuccess = true;
        }
        if (isSuccess) {
          return m.acknowledge();
        } else {
          return m.reject(true);
        }
      });
      return this.emit('task', task);
    }
  };

  TaskQueue.prototype.clear = function(callback) {
    var self;
    self = this;
    self.queue.destroy();
    return declareQueue(self, function() {
      return bindExchange(self, function() {
        subscribe(self);
        return callback();
      });
    });
  };

  connect = function(self) {
    self.connection = amqp.createConnection(self.connectionParams).on('ready', function() {
      return self.emit('connected', self);
    }).on('error', function(err) {
      return util.log('Rabbit connection error: ' + err);
    });
    return self;
  };

  declareQueue = function(self, callback) {
    var queueParams;
    queueParams = {
      durable: true,
      exclusive: false,
      autoDelete: false
    };
    return self.connection.queue(self.queueName, queueParams, function(queue) {
      self.queue = queue;
      return callback();
    });
  };

  declareExchange = function(self, callback) {
    var exchangeParams;
    exchangeParams = {
      durable: true,
      type: 'fanout',
      autoDelete: false
    };
    return self.connection.exchange(self.exchangeName, exchangeParams, function(exchange) {
      self.exchange = exchange;
      return callback();
    });
  };

  bindExchange = function(self, callback) {
    self.queue.bind(self.exchangeName, '');
    return self.queue.on('queueBindOk', function() {
      return callback();
    });
  };

  subscribe = function(self) {
    return self.queue.subscribe({
      ack: true,
      prefetchCount: 0
    }, function(message, header, deliveryInfo, m) {
      return self.handleMessage(message, header, deliveryInfo, m);
    }).addCallback(function(ok) {
      return self.consumerTag = ok.consumerTag;
    });
  };

}).call(this);
